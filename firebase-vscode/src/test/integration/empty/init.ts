import fs from "fs";
import path from "path";

import { FIREBASE_PROJECT } from "../../../utils/env";
import { FirebaseCommands } from "../../utils/page_objects/commands";
import { FirebaseSidebar } from "../../utils/page_objects/sidebar";
import { waitForTaskCompletion, waitForTaskStart } from "../../utils/task";
import {
  addTearDown,
  firebaseSuite,
  firebaseTest,
} from "../../utils/test_hooks";

addTearDown(() => {
  const emptyProjectPath = path.join(
    __dirname,
    "..",
    "..",
    "test_projects",
    "empty",
  );

  // Reset test_projects/empty to its original state.
  // This is necessary because the test modifies the project.
  fs.rmdirSync(emptyProjectPath, { recursive: true });
  // Recreate the empty project.
  fs.mkdirSync(emptyProjectPath);
});

firebaseSuite("Init Firebase", async function () {
  firebaseTest("calls init command in an empty project", async function () {
    const workbench = await browser.getWorkbench();

    const sidebar = new FirebaseSidebar(workbench);
    await sidebar.openExtensionSidebar();

    const commands = new FirebaseCommands();
    await commands.waitForUser();

    const picker = await workbench.executeCommand("firebase.selectProject");

    // Wait until at least one option is offered in the picker
    // This would timeout if the picker didn't wait for projects to be loaded.
    await picker.progress$.waitUntil(
      async () => (await picker.getQuickPicks()).length !== 0,
    );

    // Select the first project in the list or the one specified in the environment.
    await picker.selectQuickPick(FIREBASE_PROJECT || 0);

    await sidebar.runInStudioContext(async (firebase) => {
      await firebase.initFirebaseBtn.waitForExist();
      await firebase.initFirebaseBtn.waitForDisplayed();
      await firebase.initFirebaseBtn.click();
    });

    // Check the task was executed
    // Wait for the task to complete and verify it started
    const taskStarted = await waitForTaskStart("firebase init dataconnect");

    // Access the terminal where the task is running
    const terminal = await workbench.getBottomBar().openTerminalView();

    console.log(await terminal.getText());

    // Interact with the terminal by reading output and sending inputs to prompts
    await browser.waitUntil(
      async () => {
        const output = await terminal.getText();
        return output.includes(
          "Your project already has existing services. Which would you like to set up local files for?",
        );
      },
      {
        timeout: 50000,
      },
    );

    await browser.keys("Enter");

    await browser.waitUntil(async () => {
      const output = await terminal.getText();
      return output.includes(
        "Would you like to configure your backend resources now?",
      );
    });

    await browser.keys("Enter");
    await browser.waitUntil(async () => {
      const output = await terminal.getText();
      return output.includes(
        "What ID would you like to use for your new CloudSQL instance?",
      );
    });
    await browser.keys("Enter");

    await browser.waitUntil(async () => {
      const output = await terminal.getText();
      return output.includes(
        "What ID would you like to use for your new database",
      );
    });
    await browser.keys("Enter");

    await browser.waitUntil(async () => {
      const output = await terminal.getText();
      return output.includes(
        "Would you like to provision your Cloud SQL instance and database now? This will take several minutes",
      );
    });

    await browser.keys(["n", "Enter"]);

    // Assert that the task was started successfully.
    expect(
      await waitForTaskCompletion("firebase init dataconnect"),
    ).toBeTruthy();

    // Assert the files generated by the init command are present.
    const emptyProjectPath = path.join(
      __dirname,
      "..",
      "..",
      "test_projects",
      "empty",
    );

    // First, the firebase.json file should be present.
    expect(fs.existsSync(path.join(emptyProjectPath, "firebase.json"))).toBe(
      true,
    );

    // Check the contents of the firebase.json file.
    const firebaseJson = JSON.parse(
      fs.readFileSync(path.join(emptyProjectPath, "firebase.json"), "utf8"),
    );
    expect(firebaseJson).toEqual({
      dataconnect: {
        source: "dataconnect",
      },
    });

    expect(
      fs.existsSync(
        path.join(emptyProjectPath, "dataconnect", "dataconnect.yaml"),
      ),
    ).toBe(true);

    // Check the contents of the dataconnect.yaml file.
    const dataconnectYaml = fs.readFileSync(
      path.join(emptyProjectPath, "dataconnect", "dataconnect.yaml"),
      "utf8",
    );
    expect(dataconnectYaml).toContain(`specVersion: "v1beta"
serviceId: "s"
location: "asia-east1"
schema:
  source: "./schema"
  datasource:
    postgresql:
      database: "fdcdb"
      cloudSql:
        instanceId: "s-fdc"
      # schemaValidation: "COMPATIBLE"
connectorDirs: ["./connector"]`);

    expect(
      fs.existsSync(path.join(emptyProjectPath, "dataconnect", "connector")),
    ).toBe(true);

    // Check the contents of the connector directory.
    const connectorFiles = fs.readdirSync(
      path.join(emptyProjectPath, "dataconnect", "connector"),
    );
    expect(connectorFiles).toEqual([
      "connector.yaml",
      "mutations.gql",
      "queries.gql",
    ]);

    // Check the contents of the connector.yaml file.
    const connectorYaml = fs.readFileSync(
      path.join(emptyProjectPath, "dataconnect", "connector", "connector.yaml"),
      "utf8",
    );
    expect(connectorYaml).toContain(`connectorId: "default"
## ## Here's an example of how to add generated SDKs.
## ## You'll need to replace the outputDirs with ones pointing to where you want the generated code in your app.
# generate:
#   javascriptSdk:
#     outputDir: <Path where you want the generated SDK to be written to, relative to this file>
#     package: "@firebasegen/my-connector"
#     packageJsonDir: < Optional. Path to your Javascript app's package.json>
#   swiftSdk:
#     outputDir: <Path where you want the generated SDK to be written to, relative to this file>
#     package: "firebasegen/default"
#   kotlinSdk:
#     outputDir: <Path where you want the generated SDK to be written to, relative to this file>
#     package: connectors.default
`);
  });
});
